// Generated by gencpp from file rewa_msgs/CommandServo.msg
// DO NOT EDIT!


#ifndef REWA_MSGS_MESSAGE_COMMANDSERVO_H
#define REWA_MSGS_MESSAGE_COMMANDSERVO_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <rewa_msgs/ControlCommandAX12A.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandAX12A.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandMX28.h>
#include <rewa_msgs/ControlCommandMX28.h>

namespace rewa_msgs
{
template <class ContainerAllocator>
struct CommandServo_
{
  typedef CommandServo_<ContainerAllocator> Type;

  CommandServo_()
    : ID2()
    , ID3()
    , ID4()
    , ID5()
    , ID6()
    , ID7()
    , ID8()
    , ID9()
    , ID10()
    , ID11()
    , ID12()
    , ID13()  {
    }
  CommandServo_(const ContainerAllocator& _alloc)
    : ID2(_alloc)
    , ID3(_alloc)
    , ID4(_alloc)
    , ID5(_alloc)
    , ID6(_alloc)
    , ID7(_alloc)
    , ID8(_alloc)
    , ID9(_alloc)
    , ID10(_alloc)
    , ID11(_alloc)
    , ID12(_alloc)
    , ID13(_alloc)  {
  (void)_alloc;
    }



   typedef  ::rewa_msgs::ControlCommandAX12A_<ContainerAllocator>  _ID2_type;
  _ID2_type ID2;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID3_type;
  _ID3_type ID3;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID4_type;
  _ID4_type ID4;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID5_type;
  _ID5_type ID5;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID6_type;
  _ID6_type ID6;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID7_type;
  _ID7_type ID7;

   typedef  ::rewa_msgs::ControlCommandAX12A_<ContainerAllocator>  _ID8_type;
  _ID8_type ID8;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID9_type;
  _ID9_type ID9;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID10_type;
  _ID10_type ID10;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID11_type;
  _ID11_type ID11;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID12_type;
  _ID12_type ID12;

   typedef  ::rewa_msgs::ControlCommandMX28_<ContainerAllocator>  _ID13_type;
  _ID13_type ID13;





  typedef boost::shared_ptr< ::rewa_msgs::CommandServo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rewa_msgs::CommandServo_<ContainerAllocator> const> ConstPtr;

}; // struct CommandServo_

typedef ::rewa_msgs::CommandServo_<std::allocator<void> > CommandServo;

typedef boost::shared_ptr< ::rewa_msgs::CommandServo > CommandServoPtr;
typedef boost::shared_ptr< ::rewa_msgs::CommandServo const> CommandServoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::rewa_msgs::CommandServo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::rewa_msgs::CommandServo_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::rewa_msgs::CommandServo_<ContainerAllocator1> & lhs, const ::rewa_msgs::CommandServo_<ContainerAllocator2> & rhs)
{
  return lhs.ID2 == rhs.ID2 &&
    lhs.ID3 == rhs.ID3 &&
    lhs.ID4 == rhs.ID4 &&
    lhs.ID5 == rhs.ID5 &&
    lhs.ID6 == rhs.ID6 &&
    lhs.ID7 == rhs.ID7 &&
    lhs.ID8 == rhs.ID8 &&
    lhs.ID9 == rhs.ID9 &&
    lhs.ID10 == rhs.ID10 &&
    lhs.ID11 == rhs.ID11 &&
    lhs.ID12 == rhs.ID12 &&
    lhs.ID13 == rhs.ID13;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::rewa_msgs::CommandServo_<ContainerAllocator1> & lhs, const ::rewa_msgs::CommandServo_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace rewa_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::rewa_msgs::CommandServo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rewa_msgs::CommandServo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rewa_msgs::CommandServo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rewa_msgs::CommandServo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rewa_msgs::CommandServo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rewa_msgs::CommandServo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::rewa_msgs::CommandServo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "f958a627952b4e4e7996dc10180b3884";
  }

  static const char* value(const ::rewa_msgs::CommandServo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xf958a627952b4e4eULL;
  static const uint64_t static_value2 = 0x7996dc10180b3884ULL;
};

template<class ContainerAllocator>
struct DataType< ::rewa_msgs::CommandServo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "rewa_msgs/CommandServo";
  }

  static const char* value(const ::rewa_msgs::CommandServo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::rewa_msgs::CommandServo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ControlCommandAX12A ID2\n"
"ControlCommandMX28 ID3\n"
"ControlCommandMX28 ID4\n"
"ControlCommandMX28 ID5\n"
"ControlCommandMX28 ID6\n"
"ControlCommandMX28 ID7\n"
"\n"
"ControlCommandAX12A ID8\n"
"ControlCommandMX28 ID9\n"
"ControlCommandMX28 ID10\n"
"ControlCommandMX28 ID11\n"
"ControlCommandMX28 ID12\n"
"ControlCommandMX28 ID13\n"
"\n"
"================================================================================\n"
"MSG: rewa_msgs/ControlCommandAX12A\n"
"uint8 ID\n"
"\n"
"uint16 goalpos\n"
"uint16 speed\n"
"\n"
"bool torque\n"
"bool moving\n"
"\n"
"================================================================================\n"
"MSG: rewa_msgs/ControlCommandMX28\n"
"uint8 ID\n"
"\n"
"uint16 goalpos\n"
"uint16 speed\n"
"\n"
"bool torque\n"
"bool moving\n"
;
  }

  static const char* value(const ::rewa_msgs::CommandServo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::rewa_msgs::CommandServo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.ID2);
      stream.next(m.ID3);
      stream.next(m.ID4);
      stream.next(m.ID5);
      stream.next(m.ID6);
      stream.next(m.ID7);
      stream.next(m.ID8);
      stream.next(m.ID9);
      stream.next(m.ID10);
      stream.next(m.ID11);
      stream.next(m.ID12);
      stream.next(m.ID13);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct CommandServo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rewa_msgs::CommandServo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::rewa_msgs::CommandServo_<ContainerAllocator>& v)
  {
    s << indent << "ID2: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandAX12A_<ContainerAllocator> >::stream(s, indent + "  ", v.ID2);
    s << indent << "ID3: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID3);
    s << indent << "ID4: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID4);
    s << indent << "ID5: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID5);
    s << indent << "ID6: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID6);
    s << indent << "ID7: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID7);
    s << indent << "ID8: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandAX12A_<ContainerAllocator> >::stream(s, indent + "  ", v.ID8);
    s << indent << "ID9: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID9);
    s << indent << "ID10: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID10);
    s << indent << "ID11: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID11);
    s << indent << "ID12: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID12);
    s << indent << "ID13: ";
    s << std::endl;
    Printer< ::rewa_msgs::ControlCommandMX28_<ContainerAllocator> >::stream(s, indent + "  ", v.ID13);
  }
};

} // namespace message_operations
} // namespace ros

#endif // REWA_MSGS_MESSAGE_COMMANDSERVO_H
